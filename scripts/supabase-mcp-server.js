#!/usr/bin/env node

const { Client } = require('pg');

const COMMANDS = {
  'ensure-schema': ensureReportsSchema,
  help: () => {
    console.log('Supabase MCP server commands:');
    console.log('  ensure-schema  Ensures the reports table exists with required columns.');
  },
};

async function main() {
  const command = process.argv[2] || 'help';
  const handler = COMMANDS[command];

  if (!handler) {
    console.error(`Unknown command: ${command}`);
    COMMANDS.help();
    process.exit(1);
  }

  try {
    await handler();
  } catch (error) {
    console.error('Supabase MCP command failed.');
    console.error(error);
    process.exit(1);
  }
}

async function ensureReportsSchema() {
  const connectionString =
    process.env.SUPABASE_DB_URL || process.env.SUPABASE_MCP_DATABASE_URL || process.env.DATABASE_URL;

  if (!connectionString) {
    throw new Error(
      'Set SUPABASE_DB_URL (or SUPABASE_MCP_DATABASE_URL / DATABASE_URL) to the Postgres connection string for your Supabase project.'
    );
  }

  const client = new Client({
    connectionString,
    ssl: { rejectUnauthorized: false },
  });

  await client.connect();

  const results = { createdTable: false, alteredColumns: [], createdIndex: false, createdTrigger: false };

  try {
    const tableExistsResult = await client.query("select to_regclass('public.reports') as table_id;");
    const tableExists = Boolean(tableExistsResult.rows[0]?.table_id);

    if (!tableExists) {
      await client.query(`
        create table public.reports (
          id bigint generated by default as identity primary key,
          user_id uuid references auth.users (id),
          report_name text,
          report_state jsonb,
          report_html text,
          created_at timestamptz default timezone('utc'::text, now()) not null,
          updated_at timestamptz default timezone('utc'::text, now()) not null
        );
      `);
      results.createdTable = true;
    }

    const { rows: existingColumnsRows } = await client.query(
      "select column_name from information_schema.columns where table_schema = 'public' and table_name = 'reports';"
    );

    const existingColumns = new Set(existingColumnsRows.map((row) => row.column_name));

    const columnsToEnsure = [
      {
        name: 'user_id',
        sql: "add column if not exists user_id uuid references auth.users (id)",
      },
      {
        name: 'report_name',
        sql: 'add column if not exists report_name text',
      },
      {
        name: 'report_state',
        sql: 'add column if not exists report_state jsonb',
      },
      {
        name: 'report_html',
        sql: 'add column if not exists report_html text',
      },
      {
        name: 'created_at',
        sql: "add column if not exists created_at timestamptz default timezone('utc'::text, now()) not null",
      },
      {
        name: 'updated_at',
        sql: "add column if not exists updated_at timestamptz default timezone('utc'::text, now()) not null",
      },
    ];

    const missingColumns = columnsToEnsure.filter((entry) => !existingColumns.has(entry.name));

    if (missingColumns.length) {
      const alterStatements = missingColumns.map((entry) => entry.sql).join(',\n  ');

      await client.query(`
        alter table public.reports
          ${alterStatements};
      `);
      results.alteredColumns = missingColumns.map((column) => column.name);
    }

    const { rowCount: indexCount } = await client.query(
      "select 1 from pg_indexes where schemaname = 'public' and indexname = 'reports_user_id_idx'"
    );

    if (!indexCount) {
      await client.query('create index reports_user_id_idx on public.reports (user_id);');
      results.createdIndex = true;
    }

    const triggerResult = await client.query(
      "select 1 from pg_trigger where tgname = 'handle_reports_updated_at' and tgenabled != 'D';"
    );

    if (!triggerResult.rowCount) {
      await client.query(`
        do $$
        begin
          if not exists (
            select 1 from pg_proc where proname = 'handle_updated_at' and pronamespace = 'public'::regnamespace
          ) then
            execute $$
              create function public.handle_updated_at()
              returns trigger
              language plpgsql
              as $$
              begin
                new.updated_at = timezone('utc'::text, now());
                return new;
              end;
              $$;
            $$;
          end if;
        end;
        $$;
      `);

      await client.query(`
        create trigger handle_reports_updated_at
          before update on public.reports
          for each row
          execute function public.handle_updated_at();
      `);

      results.createdTrigger = true;
    }

    const humanSummary = [];

    if (results.createdTable) {
      humanSummary.push('created reports table');
    }

    if (results.alteredColumns.length) {
      humanSummary.push(`ensured columns: ${results.alteredColumns.join(', ')}`);
    }

    if (results.createdIndex) {
      humanSummary.push('added reports_user_id_idx index');
    }

    if (results.createdTrigger) {
      humanSummary.push('created handle_reports_updated_at trigger');
    }

    if (!humanSummary.length) {
      humanSummary.push('reports schema already satisfied');
    }

    console.log(JSON.stringify({ success: true, summary: humanSummary, details: results }, null, 2));
  } finally {
    await client.end();
  }
}

main();
